# 正则表达式的表示类型
* raw string类型（原生字符串类型）
```
re库采用raw string类型表示正则表达式，表示为：
例如： r'[1‐9]\d{5}'    r'\d{3}‐\d{8}|\d{4}‐\d{7}'    raw string是不包含对转义符再次转义的字符串
re库也可以采用string类型表示正则表达式，但更繁琐
例如：'[1‐9]\\d{5}'   '\\d{3}‐\\d{8}|\\d{4}‐\\d{7}'
建议：当正则表达式包含转义符时，使用raw string
```

# re.search()
```python
def search(pattern, string, flags=0):
    """Scan through string looking for a match to the pattern, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).search(string)
```
```
在一个字符串中搜索匹配正则表达式的第一个位置返回match对象
pattern : 正则表达式的字符串或原生字符串表示
string : 待匹配字符串
flags  : 正则表达式使用时的控制标记
```
***
**多个标记可以按位|来指定，如re.I|re.M**
***
|常用标记|说明|
|:-----|:-----|
|re.A   re.ASCII| assume ascii "locale"|
|re.I   re.IGNORECASE | ignore case|
|re.L   re.LOCALE| assume current 8-bit locale|
|re.U   re.UNICODE| assume unicode "locale"|
|re.M   re.MULTILINE| make anchors look for newline|
|re.S   re.DOTALL | make dot match newline|
|re.X   re.VERBOSE| ignore whitespace and comments|
***

***
```python
import re
match=re.search(pattern=r'[0-9]\d{5}',string='BIT 100081',flags=0)
print(match)
>>><_sre.SRE_Match object; span=(4, 10), match='100081'>

print(type(match))
>>><class '_sre.SRE_Match'>

if match:
    print(match.group(0))
>>>100081
```

***
# re.match()
```python
def match(pattern, string, flags=0):
    """Try to apply the pattern at the start of the string, returning
    a match object, or None if no match was found."""
    return _compile(pattern, flags).match(string)
```
```
从一个字符串的开始位置起匹配正则表达式返回match对象
pattern : 正则表达式的字符串或原生字符串表示
string : 待匹配字符串
flags  : 正则表达式使用时的控制标记
```
```python
import re
match1=re.match(pattern=r'[0-9]\d{5}',string='BIT 100081',flags=0)
print(match1)
>>>None

match2=re.match(pattern=r'[0-9]\d{5}',string='100081 BIT',flags=0)
print(match2,"***",type(match2))
>>><_sre.SRE_Match object; span=(0, 6), match='100081'> *** <class '_sre.SRE_Match'>

print(match2.group(0))>>>100081
```
**match()是从字符串开头开始匹配，而search()它是搜索式的匹配，随便从哪里开始，找完为止**

***
# re.findall()
```python
def findall(pattern, string, flags=0):
    """Return a list of all non-overlapping matches in the string.
    If one or more capturing groups are present in the pattern, return
    a list of groups; this will be a list of tuples if the pattern
    has more than one group.
    Empty matches are included in the result."""
    return _compile(pattern, flags).findall(string)
```
**搜索字符串，以列表类型返回全部能匹配的子串**
```python
import re
ls=re.findall(pattern=r'[0-9]\d{5}',string='BIT100081 TSU100084',flags=0)
print(ls)
>>>['100081', '100084']
```

***
# re.split()
```python
def split(pattern, string, maxsplit=0, flags=0):
    """Split the source string by the occurrences of the pattern,
    returning a list containing the resulting substrings.  If
    capturing parentheses are used in pattern, then the text of all
    groups in the pattern are also returned as part of the resulting
    list.  If maxsplit is nonzero, at most maxsplit splits occur,
    and the remainder of the string is returned as the final element
    of the list."""
    return _compile(pattern, flags).split(string, maxsplit)
```
```
将一个字符串按照正则表达式匹配结果进行分割返回列表类型
pattern : 正则表达式的字符串或原生字符串表示
string : 待匹配字符串
maxsplit: 最大分割数，剩余部分作为最后一个元素输出
flags  : 正则表达式使用时的控制标记
```
```python
import re
ls0=re.split(pattern=r'[0-9]\d{5}',string='BIT100081 TSU100084',maxsplit=0,flags=0)
print(ls0)
>>>['BIT', ' TSU', '']

ls1=re.split(pattern=r'[0-9]\d{5}',string='BIT100081 TSU100084',maxsplit=1,flags=0)
print(ls1)
>>>['BIT', ' TSU100084']

ls2=re.split(pattern=r'[0-9]\d{5}',string='BIT100081 TSU100084',maxsplit=2,flags=0)
print(ls2)
>>>['BIT', ' TSU', '']
```
